"""
Solving Date    : 2024.02.20
Solving Time    : 35m
Title           : 문자열 비교하기
tags            : 다이나믹 프로그래밍, 문자열
url             : https://www.acmicpc.net/problem/17180
runtime         : 108 ms
memory          : 34188 KB
"""

n, m = map(int, input().split())
i = lambda: list(map(lambda y: ord(y), input()))
a = i()
b = i()

dp = [[9999 for _ in range(m+1)] for _ in range(n+1)]
dp[0][0] = 0

for i in range(1, n+1):
    for j in range(1, m+1):
        dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + abs(a[i-1]-b[j-1])

print(dp[-1][-1])

"""

- 처음 든 생각은, 늘이는게 되면 반대로 줄여서 시퀀스 똑같으면 되는거 아닌가? 했지만
    - 줄이면 "차이"를 온전히 계산 할 수 없음.
    - aaabbb ab는 거리가 0이 되지만, aaabbb ac는 거리가 3이 된다.
바로 기각하고,

- 문자열 하나 늘리는거랑, 그냥 진행하는걸 구분해서 카운팅하면 되겠다.
    - 근데 이 과정에서, 앞에서 늘리는 과정이 뒤에서 어떤 영향을 줄 지 모른다는게 문제.
    - "ab...az", "b....a" 이런게 있으면 "b-b"이득을 위해서 "z-a"손해를 얻는다.
    - 동적으로 계산해야겠다고 생각함.
- 또한, 문자열을 늘리는 과정을 반대로 생각하면 인덱스를 증가시키지 않는것과 똑같다고 생각하여
    동적으로 계산할 때, 각 길이 N, M까지 모든 조합으로 하면 되겠다고 생각.

풀이:
dp[N][M] 배열을 만들고, 문자열 A, B라고 할 때,
    - i: range(0, N), j: range(0, M)
    - A[i], B[j]을 비교하여 길이를 갱신
    - dp[i][j] = min(
                    dp[i-1][j-1],   # 늘이는 단어 없이
                    dp[i-1][j],     # B[j]를 늘임
                    dp[i][j-1]      # A[i]를 늘임
                    )

- 또한, 늘인것과 안늘인것을 구분하지 않고 계산하는데 문제가 없다.
    ex) "aB", "bB"에서 각 두번째 B를 비교할 때 다음 방식으로 최솟값을 계산하는데
    - ["aB", "bB"]
    - ["abB", "bbB"]
    - ["aaB", "bbB"]
    이전계산 상관없이 현재 계산하는 값이 항상 똑같고(원본데이터 위치 그대로),
    이후 비교할 데이터에도 영향이 없기 때문이다.

설명이 좀 부족한감이 있는디, 암튼 추가로.
- 두 문자열의 길이를 동일하게 만들어야 한다는 점은 각 인덱스를 마지막까지 진행시키면 충족됨.
- 알파벳에 변화가 없고, 늘이는것만 되기 때문에 "시퀀스"에는 변화가 없음. ("aaaabb" == "ab")
"""