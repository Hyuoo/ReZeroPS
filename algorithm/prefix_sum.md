## prefix_sum (누적 합)

#### "구간 합"을 "여러번"구하는 문제에서 사용된다.

배열 또는 리스트가 있을 때, 
인덱스 {a-b}까지의 합을 구하는 과정이 여러번 반복 될 경우 
굉장히 비효율적으로 **반복 연산**을 하게 됨.
  
    ( ar[a] + ar[a+1] + ar[a+2] + ... + ar[b-1] + ar[b] )

그럴 때 이 누적 합을 계산 한 새로운 배열을 만들고,
**인덱스 접근 2번**만을 이용해서 구간의 합을 얻는 방법.   
(0번 인덱스부터 해당 인덱스까지의 합을 모두 구함)

배열 `[1, 2, 4, 7, 11]` 가 있다고 할 때   
누적합 배열은 `[0, 1, 3, 7, 14, 25]` 가 된다.   
*(누적합 배열 맨 앞에 0이 들어가야 <u>1번째 값</u>을 더하는 경우가 가능하다.)*

풀어서 쓰면 `[1, 1+2, 1+2+4, 1+2+4+7, 1+2+4+7+11]`   
이 상태에서 3, 4번째의 합을 구할 경우 *(4번째 빼기 2번째)* 를 하면 된다.   
=> `(1+2+4+7) - (1+2)` => `4+7`

- 즉, `sum( ar[A] ~ ar[B] )` == `prefix_sum[B] - prefix_sum[A-1]`

이런식으로 양 끝의 인덱스 2개만 접근해서,
100개 구간의 합도 100번 더하는 과정이 필요가 없어진다.

---

### 누적합 생성 코드.. 숏코딩 포함

말 그대로 누적시켜서 더한 배열을 생성하면 된다.   
앞에서부터 더하고 더하고..

origin_ar : `[1, 8, 6, 15, 31, 20, 18]`   
prefix_sum : `[0, 1, 9, 15, 30, 61, 81, 99]`

```python
ar = [1, 8, 6, 15, 31, 20, 18]
s = 0
prefix_sum = [(s:=s+i) for i in [0]+ar]
```

```python
ar = [1, 8, 6, 15, 31, 20, 18]
prefix_sum = [0]
for i in ar:
    # prefix_sum.append(prefix_sum[-1]+i)
    prefix_sum += [prefix_sum[-1]+i]
```

```python
ar = [1, 8, 6, 15, 31, 20, 18]
ar = [0] + ar
for i in range(len(ar)-1):
    ar[i+1] += ar[i]
```

---

### 관련 문제

- [S3 | 구간 합 구하기 4](https://www.acmicpc.net/problem/11659) [[풀이 코드](/baekjoon_online_judge/200_silver/3_400/BOJ%2011659.py)]