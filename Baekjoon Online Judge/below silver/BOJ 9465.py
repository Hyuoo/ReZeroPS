t = int(input())

for _ in range(t):
    n = int(input())
    a = list(map(int,input().split()))
    b = list(map(int,input().split()))
    acc = [0,0,0]
    for i in range(n):
        top = max(acc[1]+a[i], acc[2]+a[i])
        bot = max(acc[0]+b[i], acc[2]+b[i])
        nop = max(acc[0], acc[1], acc[2])
        acc = [top, bot, nop]
    print(max(acc))
'''
스티커
풀이시간 : 23m

DP문제.

접근&풀이:
일단 인접하는곳을 다 떼는데, 2행으로만 주어지면 세로로는 둘중 하나만 고를수있단거네
그럼 어케 한줄로 사악 훑으면 되지않을까했는데

생각과는 달리 1행 사악 훑고 2행은 1행과 같이 사악 훑어서 최댓값 만들어주니
중복되어 들어가는 값이 있어 폴트.

다시 첨에 한 생각으로 돌아가서 가능한 경우를 생각해서
1. 위에걸 고르는 경우
2. 아래를 고르는 경우
3. 안고르는 경우
각 경우마다 최대값을 갱신해주었다.

위에를 선택하려면 이전에 {아래를 골랐거나, 안골랐거나}
아래를 선택하려면 이전에 {위를 골랐거나, 안골랐거나}
안고르면 이전까지 모든 경우 중 최댓값

이렇게 갱신해가며 좌에서 우로 싹 훑어서 끝.
'''
